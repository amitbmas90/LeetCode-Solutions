"""
We are interested in the size of largest connected component which contains one of the nodes in the "initial" list.
Therefore, we need to find group (connected component) for each node as well as keep track of the sizes as we construct
each group.

It took me some time to figure out how to deal with infection. There are two ways to do this.
* Update infection status of each node in the current component if we have a new infected node added to the
connected component. This will be very expensive.
* Only keep track of the infection status of "root" node of each connected component.
However we still need O(N) to keep track because there is a case that each node might be infected and
each belongs to one individual component.

Obviously the second option is superior.
"""


class DSU:
    def __init__(self, n):
        self.groups = list(range(n))
        self.ranks = [0] * n
        self.sizes = [1] * n
        self.infected = [False] * n

    def find(self, i):
        if self.groups[i] == i:
            return i
        return self.find(self.groups[i])

    def union(self, x, y):
        gx = self.find(x)
        gy = self.find(y)
        if gx != gy:
            if self.infected[gx] or self.infected[gy]:
                self.infected[gx] = True
                self.infected[gy] = True

            if self.ranks[gx] > self.ranks[gy]:
                self.groups[gy] = gx
                self.sizes[gx] += 1
            elif self.ranks[gx] < self.ranks[gy]:
                self.groups[gx] = gy
                self.sizes[gy] += 1
            else:
                self.groups[gy] = gx
                self.ranks[gx] += 1
                self.sizes[gx] += 1


class Solution:
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        n = len(graph)
        dsu = DSU(n)
        for node in initial:
            dsu.infected[node] = True

        for x, row in enumerate(graph):
            for y, val in enumerate(row):
                if val == 1:
                    dsu.union(x, y)
        res = -1
        max_size_so_far = -float('inf')
        for node in initial:
            group = dsu.find(node)
            group_size = dsu.sizes[group]
            if group_size > max_size_so_far:
                max_size_so_far = group_size
                res = node
            elif group_size == max_size_so_far and node < res:
                res = node
        return res
